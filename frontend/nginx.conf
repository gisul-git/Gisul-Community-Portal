server {
    listen 80;
    server_name community.gisul.co.in;
    root /usr/share/nginx/html;
    
    # Allow larger request bodies for POST requests (analytics, uploads, etc.)
    client_max_body_size 100M;
    client_body_buffer_size 128k;
    
    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    
    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css text/xml text/javascript application/x-javascript application/xml+rss application/json application/javascript;
    
    # Cache static assets
    location ~* \.(jpg|jpeg|png|gif|ico|css|js|svg|woff|woff2|ttf|eot)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
    
    # Named location for backend errors - returns JSON instead of HTML
    location @backend_error {
        default_type application/json;
        return 502 '{"detail":"Backend unavailable"}';
    }
    
    # ============================================================
    # Backend API Routes (Order: Exact > Prefix ^~ > Regex > Prefix)
    # ============================================================
    
    # Exact match for /analytics/query - highest priority for POST requests
    location = /analytics/query {
        proxy_pass http://backend:8000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        # Use X-Forwarded-Proto from upstream (VM nginx) if present, otherwise use $scheme
        # This preserves the original protocol (https) from the client through the proxy chain
        proxy_set_header X-Forwarded-Proto $http_x_forwarded_proto;
        proxy_cache_bypass $http_upgrade;
        proxy_read_timeout 300s;
        proxy_connect_timeout 10s;
        proxy_send_timeout 300s;
        proxy_intercept_errors on;
        error_page 502 503 504 = @backend_error;
        
        # Handle CORS preflight OPTIONS requests
        if ($request_method = OPTIONS) {
            add_header Access-Control-Allow-Origin * always;
            add_header Access-Control-Allow-Methods "GET, POST, OPTIONS" always;
            add_header Access-Control-Allow-Headers "Authorization, Content-Type" always;
            add_header Access-Control-Max-Age 1728000 always;
            add_header Content-Type 'text/plain; charset=utf-8' always;
            add_header Content-Length 0 always;
            return 204;
        }
    }
    
    # Prefix match with ^~ modifier - prevents regex matching and HTML fallback
    # /tasks route - MUST be before location / to prevent HTML fallback
    location ^~ /tasks {
        proxy_pass http://backend:8000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        # Use X-Forwarded-Proto from upstream (VM nginx) if present, otherwise use $scheme
        # This preserves the original protocol (https) from the client through the proxy chain
        proxy_set_header X-Forwarded-Proto $http_x_forwarded_proto;
        proxy_cache_bypass $http_upgrade;
        proxy_read_timeout 300s;
        proxy_connect_timeout 10s;
        proxy_send_timeout 300s;
        proxy_intercept_errors on;
        error_page 502 503 504 = @backend_error;
    }
    
    # Prefix match with ^~ modifier - prevents regex matching and HTML fallback
    # /analytics/ routes (except /analytics/query which is handled above)
    location ^~ /analytics/ {
        proxy_pass http://backend:8000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        # Use X-Forwarded-Proto from upstream (VM nginx) if present, otherwise use $scheme
        # This preserves the original protocol (https) from the client through the proxy chain
        proxy_set_header X-Forwarded-Proto $http_x_forwarded_proto;
        proxy_cache_bypass $http_upgrade;
        proxy_read_timeout 300s;
        proxy_connect_timeout 10s;
        proxy_send_timeout 300s;
        proxy_intercept_errors on;
        error_page 502 503 504 = @backend_error;
    }
    
    # Regex match for /admin/*, /trainer/*, and /customer/* API endpoints
    # This ensures frontend routes like /admin/dashboard, /trainer/dashboard, /customer/dashboard fall through to SPA fallback
    location ~ ^/(admin|trainer|customer)/(login|signup|profile|upload_resume|upload_jd|search_by_text|search_by_jd|search_by_awa|bulk_upload_start|trainers_list|trainers|trainer|export_trainers_to_excel|vector_integrity|repair_vectors|clear_caches|activity_logs|requirements|approve_requirement|post_requirement|tasks/.*/cancel) {
        proxy_pass http://backend:8000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        # Use X-Forwarded-Proto from upstream (VM nginx) if present, otherwise use $scheme
        # This preserves the original protocol (https) from the client through the proxy chain
        proxy_set_header X-Forwarded-Proto $http_x_forwarded_proto;
        proxy_cache_bypass $http_upgrade;
        proxy_read_timeout 300s;
        proxy_connect_timeout 10s;
        proxy_send_timeout 300s;
        proxy_intercept_errors off;
        error_page 502 503 504 = @backend_error;
    }
    
    # Prefix match for /api/
    location /api/ {
        proxy_pass http://backend:8000/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        # Use X-Forwarded-Proto from upstream (VM nginx) if present, otherwise use $scheme
        # This preserves the original protocol (https) from the client through the proxy chain
        proxy_set_header X-Forwarded-Proto $http_x_forwarded_proto;
        proxy_cache_bypass $http_upgrade;
        proxy_read_timeout 300s;
        proxy_connect_timeout 10s;
        proxy_send_timeout 300s;
        proxy_intercept_errors off;
        error_page 502 503 504 = @backend_error;
    }
    
    # Prefix match for /api/auth/
    location /api/auth/ {
        proxy_pass http://backend:8000/api/auth/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        # Use X-Forwarded-Proto from upstream (VM nginx) if present, otherwise use $scheme
        # This preserves the original protocol (https) from the client through the proxy chain
        proxy_set_header X-Forwarded-Proto $http_x_forwarded_proto;
        proxy_cache_bypass $http_upgrade;
        proxy_read_timeout 300s;
        proxy_connect_timeout 10s;
        proxy_send_timeout 300s;
        proxy_intercept_errors off;
        error_page 502 503 504 = @backend_error;
    }
    
    # Prefix match for /log_activity
    location /log_activity {
        proxy_pass http://backend:8000/log_activity;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        # Use X-Forwarded-Proto from upstream (VM nginx) if present, otherwise use $scheme
        # This preserves the original protocol (https) from the client through the proxy chain
        proxy_set_header X-Forwarded-Proto $http_x_forwarded_proto;
        proxy_cache_bypass $http_upgrade;
        proxy_read_timeout 300s;
        proxy_connect_timeout 10s;
        proxy_send_timeout 300s;
        proxy_intercept_errors off;
        error_page 502 503 504 = @backend_error;
    }
    
    # Exact match for /docs
    location /docs {
        proxy_pass http://backend:8000/docs;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        # Use X-Forwarded-Proto from upstream (VM nginx) if present, otherwise use $scheme
        # This preserves the original protocol (https) from the client through the proxy chain
        proxy_set_header X-Forwarded-Proto $http_x_forwarded_proto;
    }
    
    # Exact match for /openapi.json
    location /openapi.json {
        proxy_pass http://backend:8000/openapi.json;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        # Use X-Forwarded-Proto from upstream (VM nginx) if present, otherwise use $scheme
        # This preserves the original protocol (https) from the client through the proxy chain
        proxy_set_header X-Forwarded-Proto $http_x_forwarded_proto;
    }
    
    # Health check endpoint
    location /health {
        access_log off;
        return 200 "healthy\n";
        add_header Content-Type text/plain;
    }
    
    # ============================================================
    # SPA Fallback (MUST be last - catch-all for frontend routes)
    # ============================================================
    # CRITICAL: Removed $uri/ to prevent 301 redirect loops with query parameters
    location / {
        try_files $uri /index.html;
        add_header Cache-Control "no-cache, no-store, must-revalidate";
        add_header Content-Type "text/html";
    }
}
